// This macro reads the json file generated by CAEN_FELib_GetDeviceTree()
// and generating a json file with the parameters that are going to be used

#include <fstream>
#include <iostream>
#include <nlohmann/json.hpp>

nlohmann::json GetBrdParameters(const nlohmann::json &inputJSON)
{
  nlohmann::json brdPar;

  for (auto &item : inputJSON.at("par").items()) {
    auto par = item.value();
    std::string name = item.key();
    std::string value = "No Value";
    std::string accessMode = "No Value";
    std::string description = "No Value";
    std::string dataType = "No Value";
    std::vector<std::string> allowedValues;
    try {
      value = par.at("value");
      accessMode = par.at("accessmode").at("value");
      description = par.at("description").at("value");
      dataType = par.at("datatype").at("value");
    } catch (...) {
    }

    if (accessMode == "READ_WRITE") {
      if (dataType == "STRING") {
        dataType = "string";
        auto nValues = std::stoi(
            static_cast<std::string>(par.at("allowedvalues").at("value")));
        for (auto i = 0; i < nValues; i++) {
          allowedValues.push_back(
              par.at("allowedvalues").at(std::to_string(i)).at("value"));
        }
      } else if (dataType == "NUMBER") {
        dataType = "number";
        allowedValues.push_back(par.at("minvalue").at("value"));
        allowedValues.push_back(par.at("maxvalue").at("value"));
        allowedValues.push_back(par.at("increment").at("value"));
      }

      nlohmann::json j;
      j["path"] = "/par/" + name;
      j["value"] = value;
      j["description"] = description;
      j["data_type"] = dataType;
      if (dataType == "string")
        j["allowed_values"] = allowedValues;
      else {
        j["min_value"] = allowedValues[0];
        j["max_value"] = allowedValues[1];
        j["increment"] = allowedValues[2];
      }

      brdPar[name] = j;
    }
  }

  return brdPar;
}

nlohmann::json GetChParameters(const nlohmann::json &inputJSON)
{
  nlohmann::json allChJSON;

  for (auto &item : inputJSON.at("ch").items()) {
    auto ch = item.key();
    if (ch != "handle") {
      nlohmann::json chJSON;
      for (auto &chPar : item.value().at("par").items()) {
        auto par = chPar.value();
        std::string name = chPar.key();
        std::string value = "No Value";
        std::string accessMode = "No Value";
        std::string description = "No Value";
        std::string dataType = "No Value";
        std::vector<std::string> allowedValues;
        try {
          value = par.at("value");
          accessMode = par.at("accessmode").at("value");
          description = par.at("description").at("value");
          dataType = par.at("datatype").at("value");
        } catch (...) {
        }

        if (accessMode == "READ_WRITE") {
          if (dataType == "STRING") {
            dataType = "string";
            auto nValues = std::stoi(
                static_cast<std::string>(par.at("allowedvalues").at("value")));
            for (auto i = 0; i < nValues; i++) {
              allowedValues.push_back(
                  par.at("allowedvalues").at(std::to_string(i)).at("value"));
            }
          } else if (dataType == "NUMBER") {
            dataType = "number";
            allowedValues.push_back(par.at("minvalue").at("value"));
            allowedValues.push_back(par.at("maxvalue").at("value"));
            allowedValues.push_back(par.at("increment").at("value"));
          }

          nlohmann::json j;
          j["path"] = "/ch/" + ch + "/par/" + name;
          j["value"] = value;
          j["description"] = description;
          j["data_type"] = dataType;
          if (dataType == "string")
            j["allowed_values"] = allowedValues;
          else {
            j["min_value"] = allowedValues[0];
            j["max_value"] = allowedValues[1];
            j["increment"] = allowedValues[2];
          }

          chJSON[name] = j;
        }
      }
      allChJSON[ch] = chJSON;
    }
  }

  return allChJSON;
}

nlohmann::json GetTraceParameters(const nlohmann::json &inputJSON)
{
  nlohmann::json traceJSON;

  for (auto &item : inputJSON.at("vtrace").items()) {
    auto ch = item.key();
    if (ch != "handle") {
      nlohmann::json chJSON;
      for (auto &chPar : item.value().at("par").items()) {
        auto par = chPar.value();
        std::string name = chPar.key();
        std::string value = "No Value";
        std::string accessMode = "No Value";
        std::string description = "No Value";
        std::string dataType = "No Value";
        std::vector<std::string> allowedValues;
        try {
          value = par.at("value");
          accessMode = par.at("accessmode").at("value");
          description = par.at("description").at("value");
          dataType = par.at("datatype").at("value");
        } catch (...) {
        }

        if (accessMode == "READ_WRITE") {
          if (dataType == "STRING") {
            dataType = "string";
            auto nValues = std::stoi(
                static_cast<std::string>(par.at("allowedvalues").at("value")));
            for (auto i = 0; i < nValues; i++) {
              allowedValues.push_back(
                  par.at("allowedvalues").at(std::to_string(i)).at("value"));
            }
          } else if (dataType == "NUMBER") {
            dataType = "number";
            allowedValues.push_back(par.at("minvalue").at("value"));
            allowedValues.push_back(par.at("maxvalue").at("value"));
            allowedValues.push_back(par.at("increment").at("value"));
          }

          nlohmann::json j;
          j["path"] = "/vtrace/" + ch + "/par/" + name;
          j["value"] = value;
          j["description"] = description;
          j["data_type"] = dataType;
          if (dataType == "string")
            j["allowed_values"] = allowedValues;
          else {
            j["min_value"] = allowedValues[0];
            j["max_value"] = allowedValues[1];
            j["increment"] = allowedValues[2];
          }

          chJSON[name] = j;
        }
      }
      traceJSON[ch] = chJSON;
    }
  }

  return traceJSON;
}

nlohmann::json GetReadDataFormatPSD()
{
  nlohmann::json readDataJSON;
  nlohmann::json channelJSON;
  channelJSON["name"] = "CHANNEL";
  channelJSON["type"] = "U8";
  channelJSON["dim"] = 0;
  readDataJSON.push_back(channelJSON);
  nlohmann::json timeStampJSON;
  timeStampJSON["name"] = "TIMESTAMP";
  timeStampJSON["type"] = "U64";
  timeStampJSON["dim"] = 0;
  readDataJSON.push_back(timeStampJSON);
  nlohmann::json timeStampNsJSON;
  timeStampNsJSON["name"] = "TIMESTAMP_NS";
  timeStampNsJSON["type"] = "DOUBLE";
  timeStampNsJSON["dim"] = 0;
  readDataJSON.push_back(timeStampNsJSON);
  nlohmann::json energyJSON;
  energyJSON["name"] = "ENERGY";
  energyJSON["type"] = "U16";
  energyJSON["dim"] = 0;
  readDataJSON.push_back(energyJSON);
  nlohmann::json energyShortJSON;
  energyShortJSON["name"] = "ENERGY_SHORT";
  energyShortJSON["type"] = "I16";
  energyShortJSON["dim"] = 0;
  readDataJSON.push_back(energyShortJSON);
  nlohmann::json flagsJSON;
  flagsJSON["name"] = "FLAGS";
  flagsJSON["type"] = "U32";
  flagsJSON["dim"] = 0;
  readDataJSON.push_back(flagsJSON);
  nlohmann::json analogProbe1JSON;
  analogProbe1JSON["name"] = "ANALOG_PROBE_1";
  analogProbe1JSON["type"] = "I16";
  analogProbe1JSON["dim"] = 1;
  readDataJSON.push_back(analogProbe1JSON);
  nlohmann::json analogProbe1TypeJSON;
  analogProbe1TypeJSON["name"] = "ANALOG_PROBE_1_TYPE";
  analogProbe1TypeJSON["type"] = "I32";
  analogProbe1TypeJSON["dim"] = 0;
  readDataJSON.push_back(analogProbe1TypeJSON);
  nlohmann::json analogProbe2JSON;
  analogProbe2JSON["name"] = "ANALOG_PROBE_2";
  analogProbe2JSON["type"] = "I16";
  analogProbe2JSON["dim"] = 1;
  readDataJSON.push_back(analogProbe2JSON);
  nlohmann::json analogProbe2TypeJSON;
  analogProbe2TypeJSON["name"] = "ANALOG_PROBE_2_TYPE";
  analogProbe2TypeJSON["type"] = "I32";
  analogProbe2TypeJSON["dim"] = 0;
  readDataJSON.push_back(analogProbe2TypeJSON);
  nlohmann::json digitalProbe1JSON;
  digitalProbe1JSON["name"] = "DIGITAL_PROBE_1";
  digitalProbe1JSON["type"] = "U8";
  digitalProbe1JSON["dim"] = 1;
  readDataJSON.push_back(digitalProbe1JSON);
  nlohmann::json digitalProbe1TypeJSON;
  digitalProbe1TypeJSON["name"] = "DIGITAL_PROBE_1_TYPE";
  digitalProbe1TypeJSON["type"] = "I32";
  digitalProbe1TypeJSON["dim"] = 0;
  readDataJSON.push_back(digitalProbe1TypeJSON);
  nlohmann::json digitalProbe2JSON;
  digitalProbe2JSON["name"] = "DIGITAL_PROBE_2";
  digitalProbe2JSON["type"] = "U8";
  digitalProbe2JSON["dim"] = 1;
  readDataJSON.push_back(digitalProbe2JSON);
  nlohmann::json digitalProbe2TypeJSON;
  digitalProbe2TypeJSON["name"] = "DIGITAL_PROBE_2_TYPE";
  digitalProbe2TypeJSON["type"] = "I32";
  digitalProbe2TypeJSON["dim"] = 0;
  readDataJSON.push_back(digitalProbe2TypeJSON);
  nlohmann::json waveformSizeJSON;
  waveformSizeJSON["name"] = "WAVEFORM_SIZE";
  waveformSizeJSON["type"] = "SIZE_T";
  waveformSizeJSON["dim"] = 0;
  readDataJSON.push_back(waveformSizeJSON);
  nlohmann::json eventSizeJSON;
  eventSizeJSON["name"] = "EVENT_SIZE";
  eventSizeJSON["type"] = "U32";
  eventSizeJSON["dim"] = 0;
  readDataJSON.push_back(eventSizeJSON);

  return readDataJSON;
}

nlohmann::json GetReadDataFormatPHA()
{
  nlohmann::json readDataJSON;
  nlohmann::json channelJSON;
  channelJSON["name"] = "CHANNEL";
  channelJSON["type"] = "U8";
  channelJSON["dim"] = 0;
  readDataJSON.push_back(channelJSON);
  nlohmann::json timeStampJSON;
  timeStampJSON["name"] = "TIMESTAMP";
  timeStampJSON["type"] = "U64";
  timeStampJSON["dim"] = 0;
  readDataJSON.push_back(timeStampJSON);
  nlohmann::json timeStampNsJSON;
  timeStampNsJSON["name"] = "TIMESTAMP_NS";
  timeStampNsJSON["type"] = "DOUBLE";
  timeStampNsJSON["dim"] = 0;
  readDataJSON.push_back(timeStampNsJSON);
  nlohmann::json energyJSON;
  energyJSON["name"] = "ENERGY";
  energyJSON["type"] = "U16";
  energyJSON["dim"] = 0;
  readDataJSON.push_back(energyJSON);
  nlohmann::json flagsJSON;
  flagsJSON["name"] = "FLAGS";
  flagsJSON["type"] = "U32";
  flagsJSON["dim"] = 0;
  readDataJSON.push_back(flagsJSON);
  nlohmann::json analogProbe1JSON;
  analogProbe1JSON["name"] = "ANALOG_PROBE_1";
  analogProbe1JSON["type"] = "I16";
  analogProbe1JSON["dim"] = 1;
  readDataJSON.push_back(analogProbe1JSON);
  nlohmann::json analogProbe1TypeJSON;
  analogProbe1TypeJSON["name"] = "ANALOG_PROBE_1_TYPE";
  analogProbe1TypeJSON["type"] = "I32";
  analogProbe1TypeJSON["dim"] = 0;
  readDataJSON.push_back(analogProbe1TypeJSON);
  nlohmann::json analogProbe2JSON;
  analogProbe2JSON["name"] = "ANALOG_PROBE_2";
  analogProbe2JSON["type"] = "I16";
  analogProbe2JSON["dim"] = 1;
  readDataJSON.push_back(analogProbe2JSON);
  nlohmann::json analogProbe2TypeJSON;
  analogProbe2TypeJSON["name"] = "ANALOG_PROBE_2_TYPE";
  analogProbe2TypeJSON["type"] = "I32";
  analogProbe2TypeJSON["dim"] = 0;
  readDataJSON.push_back(analogProbe2TypeJSON);
  nlohmann::json digitalProbe1JSON;
  digitalProbe1JSON["name"] = "DIGITAL_PROBE_1";
  digitalProbe1JSON["type"] = "U8";
  digitalProbe1JSON["dim"] = 1;
  readDataJSON.push_back(digitalProbe1JSON);
  nlohmann::json digitalProbe1TypeJSON;
  digitalProbe1TypeJSON["name"] = "DIGITAL_PROBE_1_TYPE";
  digitalProbe1TypeJSON["type"] = "I32";
  digitalProbe1TypeJSON["dim"] = 0;
  readDataJSON.push_back(digitalProbe1TypeJSON);
  nlohmann::json digitalProbe2JSON;
  digitalProbe2JSON["name"] = "DIGITAL_PROBE_2";
  digitalProbe2JSON["type"] = "U8";
  digitalProbe2JSON["dim"] = 1;
  readDataJSON.push_back(digitalProbe2JSON);
  nlohmann::json digitalProbe2TypeJSON;
  digitalProbe2TypeJSON["name"] = "DIGITAL_PROBE_2_TYPE";
  digitalProbe2TypeJSON["type"] = "I32";
  digitalProbe2TypeJSON["dim"] = 0;
  readDataJSON.push_back(digitalProbe2TypeJSON);
  nlohmann::json waveformSizeJSON;
  waveformSizeJSON["name"] = "WAVEFORM_SIZE";
  waveformSizeJSON["type"] = "SIZE_T";
  waveformSizeJSON["dim"] = 0;
  readDataJSON.push_back(waveformSizeJSON);
  nlohmann::json eventSizeJSON;
  eventSizeJSON["name"] = "EVENT_SIZE";
  eventSizeJSON["type"] = "U32";
  eventSizeJSON["dim"] = 0;
  readDataJSON.push_back(eventSizeJSON);

  return readDataJSON;
}

nlohmann::json GetReadDataFormatScope()
{
  nlohmann::json readDataJSON;
  nlohmann::json timeStampJSON;
  timeStampJSON["name"] = "TIMESTAMP";
  timeStampJSON["type"] = "U64";
  timeStampJSON["dim"] = 0;
  readDataJSON.push_back(timeStampJSON);
  nlohmann::json timeStampNsJSON;
  timeStampNsJSON["name"] = "TIMESTAMP_NS";
  timeStampNsJSON["type"] = "U64";
  timeStampNsJSON["dim"] = 0;
  readDataJSON.push_back(timeStampNsJSON);
  nlohmann::json triggerID;
  triggerID["name"] = "TRIGGER_ID";
  triggerID["type"] = "U32";
  triggerID["dim"] = 0;
  readDataJSON.push_back(triggerID);
  nlohmann::json waveform;
  waveform["name"] = "WAVEFORM";
  waveform["type"] = "I16";
  waveform["dim"] = 2;
  readDataJSON.push_back(waveform);
  nlohmann::json waveformSize;
  waveformSize["name"] = "WAVEFORM_SIZE";
  waveformSize["type"] = "SIZE_T";
  waveformSize["dim"] = 1;
  readDataJSON.push_back(waveformSize);
  nlohmann::json extra;
  extra["name"] = "EXTRA";
  extra["type"] = "U16";
  extra["dim"] = 0;
  readDataJSON.push_back(extra);
  nlohmann::json boardID;
  boardID["name"] = "BOARD_ID";
  boardID["type"] = "U8";
  boardID["dim"] = 0;
  readDataJSON.push_back(boardID);
  nlohmann::json boardFail;
  boardFail["name"] = "BOARD_FAIL";
  boardFail["type"] = "BOOL";
  boardFail["dim"] = 0;
  readDataJSON.push_back(boardFail);
  nlohmann::json eventSize;
  eventSize["name"] = "EVENT_SIZE";
  eventSize["type"] = "U32";
  eventSize["dim"] = 0;
  readDataJSON.push_back(eventSize);
  std::string readData = readDataJSON.dump();

  return readDataJSON;
}

void convert_json()
{
  auto FW = std::string("SCOPE");
  auto fileName = FW + std::string("_tree.json");
  auto inputFile = std::ifstream(fileName);
  auto inputJSON = nlohmann::json::parse(inputFile);

  nlohmann::json parameters;
  parameters["ModuleID"] = "0";
  parameters["FW"] = inputJSON["par"]["fwtype"]["value"];
  parameters["SN"] = inputJSON["par"]["serialnum"]["value"];
  parameters["URL"] = "dig1://caen.internal/usb?link_num=0";

  parameters["module_parameters"] = GetBrdParameters(inputJSON);
  parameters["channel_parameters"] = GetChParameters(inputJSON);
  parameters["trace_parameters"] = GetTraceParameters(inputJSON);
  if (FW == "PSD")
    parameters["readout_data_format"] = GetReadDataFormatPSD();
  else if (FW == "PHA")
    parameters["readout_data_format"] = GetReadDataFormatPHA();
  else if (FW == "SCOPE")
    parameters["readout_data_format"] = GetReadDataFormatScope();

  std::cout << parameters.dump(2) << std::endl;
  std::string outputFileName = std::string("Parameters_SN") +
                               std::string(parameters["SN"]) +
                               std::string("_FW") + FW + std::string(".json");
  std::ofstream outputFile(outputFileName);
  outputFile << parameters.dump(2) << std::endl;
  outputFile.close();

  std::cout << parameters["readout_data_format"] << std::endl;
}